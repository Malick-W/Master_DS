p+theme_bw()
ncomp.pls = which.min(msepcv.pls$val["CV",,])-1
ncomp.pls
summary(modele.pls)
modele.pls.fin = plsr(Espérance.de.Vie~., ncomp=ncomp.pcr,
data = data.app, scale=stdX.app)
ychap = predict(modele.pls.fin,newdata=data.test)[,1,ncomp.pls]
res.pls = data.test[,"Espérance.de.Vie"]-ychap
mean(res.pls^2)
plot(modele.pls, plottype = "scores", comps = 1:3)
plot(modele.pls, ncomp = 3, asp = 1, line = TRUE)
plot(modele.pls, plottype = "coef", ncomp=1:3, legendpos = "bottomleft",labels="name")
library(pls)
library(FactoMineR)
library(factoextra)
library(corrplot)
#On contrôle la graine du générateur pour que les valeurs tirées d'une facçon aléatoire soient toujours les mêmes:
set.seed(88)
data = read.csv2("donnees_des_pays_du_monde.csv", stringsAsFactors=TRUE)
row.names(data) = data[,1]
data = data[,2:length(data)]
data = data[,-c(4,6,10,17,18,21,22,23)]
names(data)
ACP=PCA(data,scale.unit = TRUE)
corrplot(cor(data[,1:length(data)]))
fviz_pca_var(ACP, col.var = "cos2",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE # Évite le chevauchement de texte
)
fviz_pca_ind (ACP, col.ind = "cos2",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE # Évite le chevauchement de texte
)
fviz_pca_biplot(ACP, repel = TRUE,
col.var = "#2E9FDF", # Couleur des variables
col.ind = "#696969"  # Couleur des individues
)
N=dim(data)[1]
napp=floor(3/4*N)
ntest=N-napp
Ind=sample(1:N,napp,replace=FALSE)
data.app=data[Ind,]
data.test=data[-Ind,]
modlin=lm(Espérance.de.Vie~., data=data.app)
summary(modlin)
par(mfrow=c(1,2))
res = residuals(modlin)
hist(res)
qqnorm(res)
qqline(res, col = 2)
shapiro.test(residuals(modlin))
plot.res=function(x,y,titre="")
#Une fonction utile de graphe des résidus.
{
plot(x,y,col="blue",ylab="Résidus",
xlab="Valeurs predites",main=titre)
abline(h=0,col="red")
}
par(mfrow=c(1,1))
plot.res(predict(modlin),res)
mean((residuals(modlin))**2)
pred.test=predict(modlin, newdata=data.test)
res.test=pred.test-data.test$Espérance.de.Vie
mean(res.test**2)
stdX.app = sqrt(apply(data.app[,-1],2,var)*(napp-1)/napp)
modele.pcr = pcr(Espérance.de.Vie ~.,ncomp=18,data = data.app,scale=stdX.app,validation = "CV")
msepcv.pcr = MSEP(modele.pcr,estimate=c("train","CV")) ## Erreur Quadratique de Prediction.
x = c(msepcv.pcr$val[1,,],msepcv.pcr$val[2,,])
y = c(rep("train",length(msepcv.pcr$val[1,,])),rep("cv",length(msepcv.pcr$val[2,,])))
z = c(0:18,0:18)
dt = data.frame(x,y,z)
colnames(dt) = c("MSEP","sample","comps")
p = ggplot(dt,aes(x=comps,y=MSEP,col=sample))+geom_line()
p+theme_bw()
ncomp.pcr = which.min(msepcv.pcr$val["CV",,])-1
ncomp.pcr
summary(modele.pcr)
modele.pcr.fin = pcr(Espérance.de.Vie~., ncomp=ncomp.pcr, data = data.app, scale=stdX.app)
ychap = predict(modele.pcr.fin,newdata=data.test)[,1,ncomp.pcr]
res.pcr = data.test[,"Espérance.de.Vie"]-ychap
mean(res.pcr**2)
modele.pls = plsr(Espérance.de.Vie ~.,ncomp=18,data = data.app,scale=stdX.app,validation = "CV")
msepcv.pls = MSEP(modele.pls,estimate=c("train","CV")) ## Erreur Quadratique de Prediction.
x=c(msepcv.pls$val[1,,],msepcv.pls$val[2,,])
y=c(rep("train",length(msepcv.pls$val[1,,])),rep("cv",length(msepcv.pls$val[2,,])))
z=c(0:18,0:18)
dt=data.frame(x,y,z)
colnames(dt)=c("msep","sample","comps")
p<-ggplot(dt,aes(x=comps,y=msep,col=sample))+geom_line()
p+theme_bw()
ncomp.pls = which.min(msepcv.pls$val["CV",,])-1
ncomp.pls
summary(modele.pls)
modele.pls.fin = plsr(Espérance.de.Vie~., ncomp=ncomp.pcr,
data = data.app, scale=stdX.app)
ychap = predict(modele.pls.fin,newdata=data.test)[,1,ncomp.pls]
res.pls = data.test[,"Espérance.de.Vie"]-ychap
mean(res.pls^2)
plot(modele.pls, plottype = "scores", comps = 1:3)
plot(modele.pls, ncomp = 3, asp = 1, line = TRUE)
plot(modele.pls, plottype = "coef", ncomp=1:3, legendpos = "bottomleft",labels="name")
install.packages("tidyverse")
install.packages("xgboost")
install.packages("drat", repos="https://cran.rstudio.com")
library(xgboost)
drat:::addRepo("dmlc")
install.packages("xgboost", repos="http://dmlc.ml/drat/", type = "source")
install.packages("xgboost", repos="http://dmlc.ml/drat/", type = "source")
R CMD INSTALL xgboost_0.4-1.tar.gz
library(tidyverse)
library(xgboost)
library(caret)
library(readxl)
# Import & création de noms de colonnes plus parlants :
df = read_excel("CCPP/Folds5x2_pp.xlsx")
colnames(df) = c("Temp", "VEchap", "PressAtm", "Humid", "ProdElec")
DT::datatable(head(df, n=50))
library(corrplot)
corrplot(cor(df), method = "ellipse")
library(GGally)
ggpairs(df)
ggplot(data = df, aes(x = PressAtm, y = ProdElec)) + geom_point() + geom_smooth(method = "lm")
set.seed(1337)  # Pour la 'reproductibilité'
inTrain <- createDataPartition(y = df$ProdElec, p = 0.85, list = FALSE)  # 85% des données dans le train, et le rest dans le test
training <- df[inTrain, ]
testing <- df[-inTrain, ]
X_train = xgb.DMatrix(as.matrix(training %>% select(-ProdElec)))
y_train = training$ProdElec
X_test = xgb.DMatrix(as.matrix(testing %>% select(-ProdElec)))
y_test = testing$ProdElec
xgb_trcontrol = trainControl(method = "cv", number = 5, allowParallel = TRUE,
verboseIter = FALSE, returnData = FALSE)
View(xgb_trcontrol)
xgbGrid <- expand.grid(nrounds = c(100,200),
max_depth = c(3, 5, 10, 15, 20),
colsample_bytree = seq(0.5, 0.9, length.out = 5),
## valeurs par défaut :
eta = 0.1,
gamma=0,
min_child_weight = 1,
subsample = 1
)
install.packages("xgboost")
install.packages("drat", repos="https://cran.rstudio.com")
drat:::addRepo("dmlc")
install.packages("xgboost", repos="http://dmlc.ml/drat/", type = "source")
install.packages("xgboost", repos="http://dmlc.ml/drat/", type = "source")
install.packages("xgboost")
library(xgboost)
install.packages("xgboost", repos="http://dmlc.ml/drat/", type = "source")
# load data
data(agaricus.train, package='xgboost')
data(agaricus.test, package='xgboost')
train <- agaricus.train
test <- agaricus.test
write.table(train,file="agaricus.txt")
# fit model
bst <- xgboost(data = train$data, label = train$label, max.depth = 2, eta = 1, nrounds = 2,
nthread = 2, objective = "binary:logistic")
library(xgboost)
# load data
data(agaricus.train, package='xgboost')
data(agaricus.test, package='xgboost')
train <- agaricus.train
test <- agaricus.test
# fit model
bst <- xgboost(data = train$data, label = train$label, max.depth = 2, eta = 1, nrounds = 2,
nthread = 2, objective = "binary:logistic")
# predict
pred <- predict(bst, test$data)
pred
View(train)
trian$data
train$data
train.columns
train$label
install.packages(c('repr', 'IRdisplay', 'evaluate', 'crayon', 'pbdZMQ', 'devtools', 'uuid', 'digest'))
install.packages(c("repr", "IRdisplay", "evaluate", "crayon", "pbdZMQ", "devtools", "uuid", "digest"))
install.packages(c("assertthat", "backports", "broom", "caret", "caTools", "chron", "Ckmeans.1d.dp", "classInt", "clipr", "coda", "colorspace", "data.table", "deldir", "dendextend", "doParallel", "dplyr", "DT", "e1071", "emmeans", "explor", "FactoMineR", "flexmix", "forcats", "foreach", "fpc", "ggplot2", "ggpubr", "ggrepel", "ggsignif", "git2r", "glue", "gower", "gtable", "haven", "highr", "hms", "httpuv", "ipred", "iterators", "jomo", "knitr", "labelled", "later", "lava", "lazyeval", "lme4", "lmtest", "maptools", "markdown", "mclust", "mice", "mime", "modelr", "numDeriv", "openxlsx", "ordinal", "pls", "polynom", "prabclus", "progress", "purrr", "quantreg", "R6", "Rcpp", "readxl", "recipes", "RJSONIO", "rmarkdown", "robustbase", "rpart.plot", "rstudioapi", "sandwich", "scatterD3", "shiny", "spData", "stringdist", "stringi", "stringr", "sys", "testthat", "tibble", "tidyr", "tinytex", "visNetwork", "whisker", "xfun", "xgboost", "xtable", "zip", "zoo"))
library(installr)
updateR()
setwd("~/Bureau/Master_DS/Option_Biologie")
##commencer par creer un jeu de donnees virtuel de petite taille
n = 6
# path = "/home/malick/Bureau/Master_DS/Option_Biologie/test16.csv"
# DF = read.csv(file = path)
# MatIndiv = data.matrix(DF)
# n = 16
# ncol = 4*4+3
##commencer par creer un jeu de donnees virtuel de petite taille
n = 6
ncol = 4*4+3
MatIndiv = matrix(0, nrow=n, ncol=ncol)
MatIndiv[1, ] = c(10,10,0,0,40,50,0,0,40,80,0,0,110,120,0,0,2,1,1)
MatIndiv[2, ] = c(10,20,0,0,60,60,0,0,70,80,0,0,120,130,0,0,2,1,2)
MatIndiv[3, ] = c(20,20,0,0,50,60,0,0,80,80,0,0,110,120,0,0,2,1,3)
MatIndiv[4, ] = c(10,20,0,0,50,60,0,0,80,80,0,0,110,120,0,0,2,2,4)
MatIndiv[5, ] = c(10,20,0,0,60,50,0,0,70,80,0,0,130,120,0,0,2,3,5)
MatIndiv[6, ] = c(10,20,0,0,60,40,0,0,70,40,0,0,120,120,0,0,2,3,6)
# compte le nombre d'enfants virtuels de meme genotype que l'enfant de reference
# in : enfants virtuels (matrice avec un genotype sur chaque ligne), genotype de l'enfant (vecteur)
# out : le nombre d'enfants virtuels correspondant
comparerEnf = function(EnfVirt, Enf){
# attention : on pensera a trier les vecteurs avant de les comparer
EnfTri = sort(Enf)
nb = 0
for (i in 1:nrow(EnfVirt)) {
EnfVirt_Tri = sort(EnfVirt[i,])
if (sum(abs(EnfTri - EnfVirt_Tri)) == 0) {
nb = nb + 1
}
}
return(nb)
}
# genere la liste des enfants virtuels a partir du genotype des parents pour le schema 2x-2x
# in : genotype des parents (vecteurs de taille 2)
# out : liste des enfants virtuels (matrice de 4 lignes et 2 colonnes)
genererEnfVirt22 = function(GenP1s, GenP2s){
# creer les 4 enfants virtuels pour le schema 2x-2x
# x <- c(10,20)
# y <- c(30,40)
# d1 <- expand.grid(x = x, y = y)
EnfVirt = expand.grid(x = GenP1s, y = GenP2s)
return(as.matrix(EnfVirt))
}
# calcul de la proba d'un lien entre deux parents et un enfant
# in : infos genetiques sur les deux parents et l'enfant (vecteurs de taille 17 : genotypes 4x4 + ploidie)
# out : proba du lien
calculerProbaLien = function(GenP1, GenP2, GenE){
# traiter seulement 2x-2x dans un premier temps (recuperer les ploidies et rentrer seulement si toutes sont egales a 2)
plo1 = GenP1[17]
plo2 = GenP2[17]
ploE = GenE[17]
if (plo1==2 & plo2==2 & ploE==2) {
p = 1
# boucler sur les 4 signaux en multipliant p par la nouvelle proba
# a chaque boucle :
# creer des vecteurs de taille 2 avec les alleles des parents et de l'enfant sur le signal
# generer les enfants virtuels du croisement, comparer avec l'enfant et deduire la proba
for (s in 1:4) {
GenP1S = GenP1[(4*(s-1)+1):(4*s)]
GenP2S = GenP2[(4*(s-1)+1):(4*s)]
GenES = GenE[(4*(s-1)+1):(4*s)]
G1 = GenP1S[1:2]
G2 = GenP2S[1:2]
GE = GenES[1:2]
EnfVirt = genererEnfVirt22(G1,G2)
nb = comparerEnf(EnfVirt, GE)
p = p*nb/4
}
}
return(p)
}
# construire pour un enfant la matrice des probas associee a tous les couples de parents potentiels
# in : numero de l'enfant
# out : matrice des probas (n lignes et n colonnes)
calculerProbasParents = function(e){
MatProbasParents = matrix(0, nrow=n, ncol=n)
# recuperer en amont la generation de l'enfant
# double boucle sur les parents
# ne rentrer que si le couple est envisageable (parents distincts de l'enfant, anterieurs, ...)
# calculer la proba du lien a l'aide des infos genetiques des parents et de l'enfant
# penser a renormaliser
for (i in 1:n) {
for (j in 1:n) {
if (i>j & i!=e[19] &  j!=e[19] & e[18]>MatIndiv[i, 18] & e[18]>MatIndiv[j, 18]) {
MatProbasParents[i,j] = calculerProbaLien(MatIndiv[i, ],MatIndiv[j, ],e)
}
}
}
s = sum(MatProbasParents)
if (s != 0){
MatProbasParents = MatProbasParents/s
}
return(MatProbasParents)
}
# pour un enfant, recherche du couple de parents le plus probable
# in : numero de l'enfant
# out : couple de parents le plus probable (vecteur de taille 4 : enfant/parent 1/parent 2/log-proba du lien)
recupParentsMax = function(e){
ParentsMax = c(e[19],0,0,0)
# calculer la matrice des probas pour tous les couples associes a l'enfant e
MatProbasParents = calculerProbasParents(e)
pmax = max(MatProbasParents)
if (pmax != 0){
IndMax = which(MatProbasParents == pmax, arr.ind = TRUE)
ParentsMax[4] = log(pmax)
ParentsMax[2] = round(IndMax[1])
ParentsMax[3] = round(IndMax[2])
}
# par convention : mettre 0-0 pour les parents si toutes les probas sont nulles, et 0 dans la case log-proba
return(ParentsMax)
}
# construire la genealogie de plus grande proba associee a la matrice des individus
# in : rien
# out : genealogie la plus probable (matrice de n lignes et 4 colonnes) munie de la log-vraisemblance
construireGen = function(){
Gen = matrix(0, nrow=n, ncol=4)
# boucler sur les individus
# chercher le couple le plus probable pour l'individu courant
# empiler le resultat
for (i in 1:n) {
Gen[i,] = recupParentsMax(MatIndiv[i, ])
}
return(list(Gen = Gen, lLik = sum(Gen[, 4])))
}
library("igraph")
GenMax = construireGen()
nodes = data.frame(id=GenMax$Gen[,1],
gen=MatIndiv[,18])
links = data.frame()
for (i in 1:n) {
if (GenMax$Gen[i,4] != 0){
link1 = data.frame(from=GenMax$Gen[i,2],
to=GenMax$Gen[i,1],
weight=round(exp(GenMax$Gen[i,4]),2))
link2 = data.frame(from=GenMax$Gen[i,3],
to=GenMax$Gen[i,1],
weight=round(exp(GenMax$Gen[i,4]),2))
links = rbind(links,link1,link2)
}
}
net = graph_from_data_frame(d=links, vertices=nodes, directed=TRUE)
net
library('RColorBrewer')
nombre_de_generation = max(MatIndiv[,18])
#colrs = rainbow(nombre_de_generation, alpha=.5)
colrs = brewer.pal(nombre_de_generation, "Set2")
# Attribuer des couleurs selon le type de média
V(net)$color = colrs[V(net)$gen]
V(net)$size = 12
#Fonte : 1 normal, 2 gras, 3, italique, 4 italique gras, 5 symbole
V(net)$label.font = 2
# Épaisseur des liens fonction de l'intensité
E(net)$width = E(net)$weight*12
# Changer la taille des flèches et la couleur des liens
E(net)$arrow.size = .15 #Taille des fléches, 1 par défaut
E(net)$arrow.width = 1 #Épaisseur des flèches, 1 par défaut
E(net)$edge.lty = 2 #Type de ligne
E(net)$label = E(net)$weight #Vecteur de type caractère utilisé pour nommer les liens
E(net)$edge.label.family = "Helvetica" #Police des labels (e.g.“Times”, “Helvetica”)
E(net)$edge.label.cex = 0.1 #Taille de la police pour les labels des liens
E(net)$edge.color = "gray80"
E(net)$width = 1+E(net)$weight*6
E(net)$edge.label = E(net)$weight
plot(net, main ="Représentation de la genealogie")
# https://f.hypotheses.org/wp-content/blogs.dir/2996/files/2017/02/visualiseR.pdf
############################################################################################
# path = "/home/malick/Bureau/Master_DS/Option_Biologie/test16.csv"
# DF = read.csv(file = path)
# MatIndiv = data.matrix(DF)
# n = 16
# ncol = 4*4+3
##commencer par creer un jeu de donnees virtuel de petite taille
n = 6
ncol = 4*4+3
MatIndiv = matrix(0, nrow=n, ncol=ncol)
MatIndiv[1, ] = c(10,10,0,0,40,50,0,0,40,80,0,0,110,120,0,0,2,1,1)
MatIndiv[2, ] = c(10,20,0,0,60,60,0,0,70,80,0,0,120,130,0,0,2,1,2)
MatIndiv[3, ] = c(20,20,0,0,50,60,0,0,80,80,0,0,110,120,0,0,2,1,3)
MatIndiv[4, ] = c(10,20,0,0,50,60,0,0,80,80,0,0,110,120,0,0,2,2,4)
MatIndiv[5, ] = c(10,20,0,0,60,50,0,0,70,80,0,0,130,120,0,0,2,3,5)
MatIndiv[6, ] = c(10,20,0,0,60,40,0,0,70,40,0,0,120,120,0,0,2,3,6)
# compte le nombre d'enfants virtuels de meme genotype que l'enfant de reference
# in : enfants virtuels (matrice avec un genotype sur chaque ligne), genotype de l'enfant (vecteur)
# out : le nombre d'enfants virtuels correspondant
comparerEnf = function(EnfVirt, Enf){
# attention : on pensera a trier les vecteurs avant de les comparer
EnfTri = sort(Enf)
nb = 0
for (i in 1:nrow(EnfVirt)) {
EnfVirt_Tri = sort(EnfVirt[i,])
if (sum(abs(EnfTri - EnfVirt_Tri)) == 0) {
nb = nb + 1
}
}
return(nb)
}
# genere la liste des enfants virtuels a partir du genotype des parents pour le schema 2x-2x
# in : genotype des parents (vecteurs de taille 2)
# out : liste des enfants virtuels (matrice de 4 lignes et 2 colonnes)
genererEnfVirt22 = function(GenP1s, GenP2s){
# creer les 4 enfants virtuels pour le schema 2x-2x
# x <- c(10,20)
# y <- c(30,40)
# d1 <- expand.grid(x = x, y = y)
EnfVirt = expand.grid(x = GenP1s, y = GenP2s)
return(as.matrix(EnfVirt))
}
# calcul de la proba d'un lien entre deux parents et un enfant
# in : infos genetiques sur les deux parents et l'enfant (vecteurs de taille 17 : genotypes 4x4 + ploidie)
# out : proba du lien
calculerProbaLien = function(GenP1, GenP2, GenE){
# traiter seulement 2x-2x dans un premier temps (recuperer les ploidies et rentrer seulement si toutes sont egales a 2)
plo1 = GenP1[17]
plo2 = GenP2[17]
ploE = GenE[17]
if (plo1==2 & plo2==2 & ploE==2) {
p = 1
# boucler sur les 4 signaux en multipliant p par la nouvelle proba
# a chaque boucle :
# creer des vecteurs de taille 2 avec les alleles des parents et de l'enfant sur le signal
# generer les enfants virtuels du croisement, comparer avec l'enfant et deduire la proba
for (s in 1:4) {
GenP1S = GenP1[(4*(s-1)+1):(4*s)]
GenP2S = GenP2[(4*(s-1)+1):(4*s)]
GenES = GenE[(4*(s-1)+1):(4*s)]
G1 = GenP1S[1:2]
G2 = GenP2S[1:2]
GE = GenES[1:2]
EnfVirt = genererEnfVirt22(G1,G2)
nb = comparerEnf(EnfVirt, GE)
p = p*nb/4
}
}
return(p)
}
# construire pour un enfant la matrice des probas associee a tous les couples de parents potentiels
# in : numero de l'enfant
# out : matrice des probas (n lignes et n colonnes)
calculerProbasParents = function(e){
MatProbasParents = matrix(0, nrow=n, ncol=n)
# recuperer en amont la generation de l'enfant
# double boucle sur les parents
# ne rentrer que si le couple est envisageable (parents distincts de l'enfant, anterieurs, ...)
# calculer la proba du lien a l'aide des infos genetiques des parents et de l'enfant
# penser a renormaliser
for (i in 1:n) {
for (j in 1:n) {
if (i>j & i!=e[19] &  j!=e[19] & e[18]>MatIndiv[i, 18] & e[18]>MatIndiv[j, 18]) {
MatProbasParents[i,j] = calculerProbaLien(MatIndiv[i, ],MatIndiv[j, ],e)
}
}
}
s = sum(MatProbasParents)
if (s != 0){
MatProbasParents = MatProbasParents/s
}
return(MatProbasParents)
}
# pour un enfant, recherche du couple de parents le plus probable
# in : numero de l'enfant
# out : couple de parents le plus probable (vecteur de taille 4 : enfant/parent 1/parent 2/log-proba du lien)
recupParentsMax = function(e){
ParentsMax = c(e[19],0,0,0)
# calculer la matrice des probas pour tous les couples associes a l'enfant e
MatProbasParents = calculerProbasParents(e)
pmax = max(MatProbasParents)
if (pmax != 0){
IndMax = which(MatProbasParents == pmax, arr.ind = TRUE)
ParentsMax[4] = log(pmax)
ParentsMax[2] = round(IndMax[1])
ParentsMax[3] = round(IndMax[2])
}
# par convention : mettre 0-0 pour les parents si toutes les probas sont nulles, et 0 dans la case log-proba
return(ParentsMax)
}
# construire la genealogie de plus grande proba associee a la matrice des individus
# in : rien
# out : genealogie la plus probable (matrice de n lignes et 4 colonnes) munie de la log-vraisemblance
construireGen = function(){
Gen = matrix(0, nrow=n, ncol=4)
# boucler sur les individus
# chercher le couple le plus probable pour l'individu courant
# empiler le resultat
for (i in 1:n) {
Gen[i,] = recupParentsMax(MatIndiv[i, ])
}
return(list(Gen = Gen, lLik = sum(Gen[, 4])))
}
library("igraph")
GenMax = construireGen()
nodes = data.frame(id=GenMax$Gen[,1],
gen=MatIndiv[,18])
links = data.frame()
for (i in 1:n) {
if (GenMax$Gen[i,4] != 0){
link1 = data.frame(from=GenMax$Gen[i,2],
to=GenMax$Gen[i,1],
weight=round(exp(GenMax$Gen[i,4]),2))
link2 = data.frame(from=GenMax$Gen[i,3],
to=GenMax$Gen[i,1],
weight=round(exp(GenMax$Gen[i,4]),2))
links = rbind(links,link1,link2)
}
}
net = graph_from_data_frame(d=links, vertices=nodes, directed=TRUE)
net
library('RColorBrewer')
nombre_de_generation = max(MatIndiv[,18])
#colrs = rainbow(nombre_de_generation, alpha=.5)
colrs = brewer.pal(nombre_de_generation, "Set2")
# Attribuer des couleurs selon le type de média
V(net)$color = colrs[V(net)$gen]
V(net)$size = 12
#Fonte : 1 normal, 2 gras, 3, italique, 4 italique gras, 5 symbole
V(net)$label.font = 2
# Épaisseur des liens fonction de l'intensité
E(net)$width = E(net)$weight*12
# Changer la taille des flèches et la couleur des liens
E(net)$arrow.size = .15 #Taille des fléches, 1 par défaut
E(net)$arrow.width = 1 #Épaisseur des flèches, 1 par défaut
E(net)$edge.lty = 2 #Type de ligne
E(net)$label = E(net)$weight #Vecteur de type caractère utilisé pour nommer les liens
E(net)$edge.label.family = "Helvetica" #Police des labels (e.g.“Times”, “Helvetica”)
E(net)$edge.label.cex = 0.1 #Taille de la police pour les labels des liens
E(net)$edge.color = "gray80"
E(net)$width = 1+E(net)$weight*6
E(net)$edge.label = E(net)$weight
plot(net, main ="Représentation de la genealogie")
# https://f.hypotheses.org/wp-content/blogs.dir/2996/files/2017/02/visualiseR.pdf
############################################################################################
